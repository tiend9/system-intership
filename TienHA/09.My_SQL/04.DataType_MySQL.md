# DATA TYPE IN MY SQL

## 1. BIT

### Knowedge

- BIT là kiểu dữ liệu dùng để lưu trữ giá trị bit(0 và 1)

- Cú pháp:

  ```sql
  column_name BIT(n)
  ```

  - `1 <= n <= 64`, mặc định là 1

- BIT Literals:
  
  - Cú pháp:
  
    - `b'val'` hoặc `B'val'`
    - `0bval`
  
  - Ví dụ: `b'01'`, `B'11'`, `0b1010`

### Example

- Chọn DATABASE

```sql
SHOW DATABASES;
USE mysql;
```

- Tạo bảng:

  ```sql
  CREATE TABLE working_calendars(
      year INT,
      week INT,
      days BIT(7),
      PRIMARY KEY(year,week)
  );
  ```

![MySQL](./images/MySQL_16.png)

- Chèn dữ liệu:

  ```sql
  INSERT INTO working_calendars(year, week, days) 
  VALUES(2025, 1, b'1111110');
  ```

- Khi `SELECT`:

![MySQL](./images/MySQL_17.png)

  -> MySQL hiển thị dạng hex

- Hiển thị dạng nhị phân:

![MySQL](./images/MySQL_18.png)

- MySQL sẽ không tự thêm `0` khi trả về, dùng `LPAD`:

  ```sql
  SELECT year, week, LPAD(BIN(days), 7, '0')
  FROM working_calendars;
  ```

## 2. INT

- `INT` trong MySQL dùng để lưu số nguyên (không có phần thập phân): ví dụ 1, 100, -10.

- Hỗ trợ cả số âm và số dương.

- MySQL cung cấp nhiều loại số nguyên theo kích thước: `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT/INTEGER`, `BIGINT`.

  | **Type**    | **Bytes** | **Signed (min → max)**   | **Unsigned (min → max)** |
  | ----------- | --------- | ------------------------ | ------------------------ |
  | TINYINT     | 1         | -128 → 127               | 0 → 255                  |
  | SMALLINT    | 2         | -32768 → 32767           | 0 → 65535                |
  | MEDIUMINT   | 3         | -8388608 → 8388607       | 0 → 16777215             |
  | INT/INTEGER | 4         | -2147483648 → 2147483647 | 0 → 4294967295           |
  | BIGINT      | 8         | -9223372036854775808 → … | 0 → 18446744073709551615 |

=> Có thể đặt thuộc tính `SIGNED`(âm) hoặc `UNSIGNED`(dương)

## 3. BOOLEAN

### Introduce

- MySQL không có kiểu BOOLEAN thật sự.

- Giá trị:

  - 0 -> FALSE
  - Non-zero -> TRUE

- BOOLEAN Literals:

  - Có thể dùng: `true`, `false`, `TRUE`, `FALSE`, `True`, `False`

    → MySQL chuyển thành 1 và 0.  

### Examples

- Tạo bảng:

  ```sql
  CREATE TABLE tasks (
      id INT AUTO_INCREMENT PRIMARY KEY,
      title VARCHAR(255) NOT NULL,
      completed BOOLEAN
  );
  ```

- Chèn dữ liệu:

  ```sql
  INSERT INTO tasks(title, completed)
  VALUES ('Master MySQL Boolean type', true),
        ('Design database table', false);
  ```

- Dùng `CHECK`:

![MySQL](./images/MySQL_19.png)

### BOOLEAN OPERATOR

- Dùng `IS TRUE` thay vì `=`

  ```sql
  WHERE completed = TRUE;
  ```

- Lấy task chưa hoàn thành:

  ```sql
  WHERE completed = FALSE;
  ```

- Lấy task không phải TRUE:

  ```sql
  WHERE completed <> TRUE;
  ```

  - Bao gồm `0` và `NULL`-> Dùng `CHECK` tra

## 4. DECIMAL

### Introduction

`DECIMAL` dùng để lưu giá trị **số chính xác** (exact numeric), đặc biệt là **dữ liệu tiền tệ**.

Không giống như `FLOAT/DOUBLE`, `DECIMAL` không gây lỗi làm tròn do dùng lưu trữ dạng decimal chứ không phải **floating point**.

Cú pháp:

```sql
DECIMAL(P, D)

P (precision): tổng số chữ số (1–65)
D (scale): số chữ số sau dấu thập phân (0–30), và D ≤ P
```

- Ví dụ:

```sql
amount DECIMAL(6, 2);
```

Biến thể:

```sql
DECIMAL(P) = DECIMAL(P,0)
DECIMAL = DECIMAL(10,0)
```

## 5. DATETIME

### Kiến thức

- **DATETIME** lưu ngày + giờ theo định dạng:

  ```bash
  'YYYY-MM-DD HH:MM:SS'
  ```

### Chèn giá trị vào DATETIME

- Đúng định dạng:

  ```sql
  INSERT INTO table_name(dt) VALUES ('2023-12-31 15:30:45');
  ```

- Giá trị mặc định:

  ```sql
  NOW()              -- trả về datetime hiện tại
  CURRENT_TIMESTAMP  -- tương tự NOW()
  ```

- Ví dụ:

  ```sql
  started_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
  ```

### Các hàm làm việc với DATETIME

#### NOW()

- Lấy thời gian hiện tại:

  ```sql
  SET @dt = NOW();
  SELECT @dt;
  ```

#### DATE()

- Lấy phần ngày:

  ```sql
  WHERE DATE(create_at) = '2025-11-27'
  ```

#### TIME()

- Lấy phần giờ:

  ```sql
  WHERE TIME(create_at) = '09:23:30'
  ```

### Tách từng thành phần thời gian

```sql
SELECT 
  YEAR(@dt),
  QUARTER(@dt),
  MONTH(@dt),
  WEEK(@dt),
  DAY(@dt),
  HOUR(@dt),
  MINUTE(@dt),
  SECOND(@dt);
```

... Còn nhiều hàm nữa tại [đây](https://www.mysqltutorial.org/mysql-basics/mysql-datetime/)

## 6. TIMESTAMP

### TimeStamp ?

- **TIMESTAMP** lưu ngày + giờ theo định dạng cố định:

  ```bash
  YYYY-MM-DD HH:MM:SS
  ```

- Phạm vi:
  
  ```sql
  1970-01-01 00:00:01 UTC → 2038-01-19 03:14:07 UTC
  ```

- **TIMESTAMP** phụ thuộc Time Zone

- **TIMESTAMP** Tính năng tự động khởi tạo và cập nhật (Automatic Initialization & Updating):

  - Tự động lưu timestamp khi dòng được tạo
  - Tự động cập nhật timestamp khi dòng được chỉnh sửa

## 7. DATE

### Khái niệm

- `DATE` là 1 trong 5 kiểu thời gian của MySQL
- Định dạng:

  ```css
  YYYY-MM-DD
  ```

- Phạm vi:

  ```yaml
  1000-01-01 → 9999-12-31
  ```

### Các hàm xử lý trong DATE

- Lấy ngày giờ hiện tại:

  ```sql
  SELECT NOW();
  ```

- Lấy phần ngày của DATETIME:

  ```sql
  SELECT DATE(NOW());
  ```

- Lấy hệ thống ngày hiện tại:

  ```sql
  SELECT CURDATE();
  ```

... Còn nhiều hàm nữa check ở [đây](https://www.mysqltutorial.org/mysql-basics/mysql-time/)

## 8. TIME

### Meaning

- Đùng để lưu thời gian trong ngày hoặc khoảng thời gian
- Định dạng:

  ```yaml
  HH:MM:SS
  ```

- Khai báo:

  ```sql
  column_name TIME;
  column_name TIME(N);   -- N = 0 đến 6 (microseconds)
  ```

## 9. CHAR

### Meaning?

- `CHAR` là fixed-length(độ dài cố định)
- Khai báo:

  ```sql
  CHAR(n)
  ```

  - MySQL luôn lưu đúng n ký tự bằng cách đệm dấu cách ở cuối (padding).

- Khi truy vấn, MySQL tự động bỏ dấu cách cuối (trừ khi bật chế độ `PAD_CHAR_TO_FULL_LENGTH`).

### Ví dụ

- Tạo bảng:

  ```sql
  CREATE TABLE mysql_char_test (
      status CHAR(3)
  );
  ```

- Thêm dữ liệu:

  ```sql
  INSERT INTO mysql_char_test(status)
  VALUES ('Yes'), ('No');
  ```

## So sánh giá trị CHAR

- MySQL bỏ qua **trailing spaces**(cách đuôi) khi so sánh với các toán tử:

  ```bash
  =, <>, >, <, <=, >=
  ```

- Nhưng với `LIKE`, MySQL không bỏ trailing spaces:

  ```sql
  status LIKE 'Y'   → không match 'Y '
  ```

## 10. VARCHAR

## Information

- `VARCHAR` là kiểu chuỗi **độ dài biến đổi** (`variable-length`)
- Chiều dài tối đa có thể khai báo:

  ```sql
  VARCHAR(65535)
  ```

- Dữ liệu vượt quá độ dài `VARCHAR` -> báo lỗi

- `VARCHAR` và khoảng trắng:

  - Không tự động **padding** (lót vào) như CHAR. MySQL giữ nguyên khoảng trắng khi lưu và khi truy vấn.

    ```sql
    INSERT INTO items(title) VALUES ('AB ');
    SELECT title, LENGTH(title) FROM items;
    ```

    - Kết quả:

      ```sql
      title = 'AB ', LENGTH = 3
      ```

- **Truncation**(cắt cụt) khi có **trailing spaces**(cách đuôi) làm vượt chiều dài:

  - Ví dụ:

    ```sql
    INSERT INTO items(title) VALUES ('ABC ');
    ```

    - Chuỗi thực tế dài 4 nhưng VARCHAR(3):

      - MySQL cắt bỏ **trailing space** để còn 'ABC'
      - Chèn thành công nhưng báo `warning`:

## 11. TEXT

### Concept

- `TEXT` là kiểu dữ liệu dùng để **lưu** chuỗi văn bản dài, từ vài byte tới vài GB.
- Không cần khai báo chiều dài như `CHAR/VARCHAR`.
- MySQL không **pad** hoặc **trim** khoảng trắng khi chèn hoặc truy vấn.
- Dữ liệu TEXT lưu trên đĩa, không nằm trong bộ nhớ → truy vấn chậm hơn `CHAR/VARCHAR`.

  | TEXT type      | Kích thước tối đa           | Overhead | Khi nào dùng                            |
  | -------------- | --------------------------- | -------- | ----------------------------------------|
  | **TINYTEXT**   | 255 bytes (~255 ký tự)      | 1 byte   | Văn bản ngắn, không yêu cầu sắp xếp     |
  | **TEXT**       | 64 KB (~65,535 ký tự)       | 2 bytes  | Nội dung bài viết, mô tả sản phẩm       |
  | **MEDIUMTEXT** | 16 MB (~16,777,215 ký tự)   | 3 bytes  | Văn bản lớn, sách, whitepaper           |
  | **LONGTEXT**   | 4 GB (~4,294,967,295 ký tự) | 4 bytes  | Văn bản cực lớn, lưu trữ dữ liệu cực dài|
  
## 12. BINARY

### Tổng hợp

- `BINARY` là kiểu dữ liệu lưu trữ dữ liệu nhị phân cố định (**fixed-length binary data**).
- Thường dùng cho: `hash`, `checksum` (ví dụ SHA-256) hoặc các dữ liệu nhị phân có độ dài cố định.

- Cú pháp:

  ```sql
  column_name BINARY(size);
  ```
  
  - `size` = số byte tối đa của dữ liệu nhị phân

### Quy tắc lưu trữ

1. **Right-padding** với 0x00

   - Nếu dữ liệu nhị phân ngắn hơn `size`, MySQL sẽ tự động thêm byte `0x00` vào bên phải để đủ độ dài.

2. Không xóa byte khi truy xuất

   - Khi `SELECT` dữ liệu, các byte `0x00` thêm lúc chèn vẫn tồn tại.

3. So sánh `byte-by-byte`

   - Khi dùng `WHERE`, `ORDER BY`, `DISTINCT`, mọi byte đều quan trọng.

   - Hai giá trị chỉ bằng nhau khi tất cả byte trùng khớp.

4. `0x00` khác với space (`0x20`)

   - Byte null và khoảng trắng (**space**) được MySQL phân biệt, ảnh hưởng tới so sánh và sắp xếp.

   - Null bytes được xếp trước space trong ORDER BY.

## 13. VARBINARY

### Overview

- `VARBINARY` để lưu trữ dữ liệu nhị phân có độ dài thay đổi.
- **Cú pháp** : Cách xác định một `VARBINARY` trong một cột trong bảng

```sql
column_name VARBINARY(max_length)
```

- `max_lengthlà` 65,535byte, tương đương với 64KB.
- Với `VARBINARY` MySQL sẽ **không thêm** `0x00`cho đủ độ dài -> Giữ nguyên Data(Khồn loại bỏ hay truy xuất Data)
- MySQL đặt byte 0x00 (**null byte**) trước khoảng trắng với lệnh `ORDER`,`BY` và `DISTINCT`
- Khi chèn dữ liệu vượt quá `max-length` thì MySQL sẽ báo lỗi.

## 14. ENUM

### Tóm tắt

- `ENUM` là **kiểu dữ liệu dạng chuỗi** trong MySQL, cho phép **một cột** chỉ **lưu trữ một giá trị duy nhất** được chọn **từ danh sách các giá trị cố định đã khai báo** khi tạo bảng.
- Nếu giá trị đưa vào không nằm trong danh sách → MySQL sẽ báo lỗi (hoặc gán giá trị rỗng tùy chế độ).
- Cú pháp:

```sql
column_name ENUM('value1', 'value2', ..., 'valueN')
```

- `value1`, `value2`, ... , `valueN` → danh sách các giá trị hợp lệ, cách nhau bằng dấu phẩy.

### Example `ENUM`

- **Bước 1**: Hãy tạo một bảng `tickets` bao gồm một `priority` column có `ENUM` kiểu:

  - Hàng `priority` chỉ chấp nhận ba giá trị Low, Medium và High
  - Đằng sau, MySQL ánh xạ các giá trị được liệt kê thành 1 mục số. Trong trường hợp này nó ánh xạ các giá trị `low`, `medium`, `high` lần lượt thành 1,2,3.

```sql
CREATE TABLE tickets (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    priority ENUM('Low', 'Medium', 'High') NOT NULL
);
```

![MySQL](./images/MySQL_20.png)

- **Bước 2**:Ta chèn 1 hàng mới vào bảng `tickets`
  
  - Ta sử dụng giá trị được xác định trước 'High' để chèn vào cột `priority`.
  - Bên cạnh các giá trị liệt kê, bạn có thể sử dụng chỉ số số của thành viên liệt kê để chèn dữ liệu vào một cột `ENUM`.

```sql
INSERT INTO tickets(title, priority)
VALUES('Scan virus for computer A', 'High');
```

- **Bước 3**: Chèn một hàng mới vào bảng `tickets` bằng cách sử dụng giá trị chỉ mục số thay vì các giá trị được xác định trước:
  
  - Thay vì sử dụng liệt kê giá trị `Low`, chúng ta sử dụng giá trị `1`. Vì `Low` được ánh xạ thành `1` nên giá trị này được chấp nhận.

```sql
INSERT INTO tickets(title, priority)
VALUES('Install Google Chrome for Mr. John', 'Medium'),
      ('Create a new user for the new employee David', 'High');     
```

- **Bước 4**: chèn nhiều hàng vào bảng `tickets`
  
  - Chúng ta định nghĩa `priority` là một cột `NOT NULL`, khi bạn chèn một hàng mới mà không chỉ định giá trị cho cột `priority`, MySQL sẽ sử dụng thành viên liệt kê đầu tiên làm giá trị mặc định. Ví dụ:

```sql
INSERT INTO tickets(title)
VALUES('Refresh the computer of Ms. Lily');
```

**Nội dung** của bảng `tickets` như sau:

![MySQL](./images/MySQL_21.png)

=> Lấy toàn bộ dữ liệu (mọi cột, mọi hàng) từ bảng tickets.

### Lưu ý

- Ở chế nghệ mysql không nghiêm ngặt thì khi chèn 1 giá trị không hợp lệ vào cột `ENUM` thì mysql sẽ sử dụng 1 chuỗi rỗng có chỉ mục bằng `0` để chèn. Còn nếu ở chế độ msql nghiêm ngặt thì khi chèn 1 giá trị không hợp lệ vào cột `ENUM` ta sẽ nhận được lỗi.

- Chèn:

```sql
INSERT INTO tickets(title, priority)
VALUES('Invalid ticket',-1);
```

- Lỗi gặp:

```sql
ERROR 1265 (01000): Data truncated for column 'priority' at row 1
```

- một cột `ENUM` có thể chấp nhận giá trị `NULL` nếu bạn định nghĩa nó là một cột có thể chấp nhận giá trị `NULL`.

### Lọc các giá trị `ENUM` của MySQL

Câu lệnh sau đây sẽ lấy tất cả các vé (`tickets`) có mức độ ưu tiên cao (`High`):

```sql
SELECT * FROM tickets WHERE priority = 'High';
```

Đầu ra:

![MySQL](./images/MySQL_22.png)

Vì giá trị liệt kê `High` được ánh xạ thành 3 lên truy vấn sau (`Query`) trả về cùng 1 tập kết quả như `High`

```sql
SELECT * FROM tickets WHERE priority = 3;
```

### Sắp xếp các giá trị `ENUM` của MySQL

- Theo thứ tự từ bé dần (use `DESC` - Descending):

```sql
SELECT title, priority
FROM tickets
ORDER BY priority DESC;
```

- Kết quả:

![MySQL](./images/MySQL_23.png)

- Theo thứ tự to dần (use `ASC` - Ascending) :>

```sql
SELECT title, priority
FROM tickets
ORDER BY priority ASC;
```

-Kết quả:
![MySQL](./images/MySQL_24.png)

- MySQL sắp xếp cột `ENUM`, các giá trị dựa trên chỉ số của chúng. Do đó, thứ tự của các thành viên phụ thuộc vào cách chúng được định nghĩa trong danh sách liệt kê.

## 15. BLOB

### Summmary (Binary Large Object)

- **BLOB (Binary Large Object)** là kiểu dữ liệu cho phép bạn lưu trữ dữ liệu nhị phân lớn, chẳng hạn như hình ảnh, âm thanh, video, v.v. BLOB hữu ích khi bạn muốn lưu trữ và truy xuất dữ liệu trong cơ sở dữ liệu của mình.

- BLOB được phân loại làm 4 loại chính:

  - **TINYBLOB** : Độ dài tối đa **255 byte**.
  - **BLOB** : Độ dài tối đa **65.535 byte**.
  - **MEDIUMBLOB** : Độ dài tối đa là **16.777.215 byte**.
  - **LONGBLOB** : Độ dài tối đa là **4.294.967.295 byte**.

=>Khi bạn tạo các bảng lưu trữ BLOB, bạn chọn loại BLOB phù hợp dựa trên kích thước dữ liệu nhị phân mà bạn dự định lưu trữ.

### Example `BLOB`

- **Bước 1**: tạo 1 bảng bao gồm cột `BLOB`

```sql
CREATE TABLE images (
   id INT PRIMARY KEY AUTO_INCREMENT,
   title VARCHAR(255) NOT NULL,
   image_data LONGBLOB NOT NULL
);
```

- **Bước 2**: Hiển thị giá trị của biến `secure_file_priv`:

  - Biến hệ thống `secure_file_priv` hạn chế các vị trí trên máy chủ MySQL mà hàm `LOAD_FILE()` có thể đọc tệp.
  - Nếu bạn cố gắng tải tệp từ các vị trí khác, hàm `LOAD_FILE()`sẽ trả về NULL.

```sql
SELECT @@secure_file_priv;
```

![MySQL](./images/MySQL_25.png)

- **Bước 3**: Chèn một hình ảnh nhị phân vào phần `image_data` và vào bảng `images` bằng cách sử dụng hàm `LOAD_FILE()`:

```sql
INSERT INTO images (title,image_data) 
VALUES ('MySQL tutorial', LOAD_FILE(`/var/lib/mysql-files/logo.png'));
```

=> Hãy đảm bảo thay thế `/var/lib/mysql-files/logo.png` bằng đường dẫn tuyệt đối thực tế tới tệp hình ảnh của bạn.

- **Bước 4**: Lấy dữ liệu nhị phân từ cột `BLOB`

```sql
SELECT * FROM images;
```

- Trong thực tế, bạn thường sử dụng các ứng dụng được viết bằng Python, PHP, Java, v.v. để đọc các tệp trong máy khách và lưu trữ chúng trong cột `BLOB`:

  - PHP BLOB
  - Python BLOB
  - BLOB Java
  